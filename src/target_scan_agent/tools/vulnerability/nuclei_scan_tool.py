import subprocess
import time
import json
import logging
from pydantic import ValidationError

from .models import NucleiScanResult, NucleiFinding
from ..common.process_utils import (
    create_temp_file,
    delete_temp_file,
    execute_process,
    terminate_process,
    wait_for_process_completion,
)


async def nuclei_scan_tool(
    target: str,
    tags: list[str],
    severity: str | None = None,
    timeout: int = 900,
    rate_limit: int = 15,
) -> NucleiScanResult:
    """
    Run Nuclei vulnerability scanner and return structured results.

    Args:
        target: URL to scan (e.g., "http://localhost:8000")
        tags: List of tags to specify which templates to run. Available tags:

            High-impact vulnerabilities:
            - 'cve': Common Vulnerabilities and Exposures (3122 templates)
            - 'xss': Cross-site scripting vulnerabilities (1239 templates)
            - 'rce': Remote code execution vulnerabilities (732 templates)
            - 'lfi': Local file inclusion vulnerabilities (764 templates)
            - 'sqli': SQL injection vulnerabilities (472 templates)

            Technology detection and exposure:
            - 'tech': Technology and software detection (776 templates)
            - 'exposure': Information disclosure and exposure risks (1084 templates)
            - 'detect': General detection templates (466 templates)
            - 'panel': Web panels and administrative interfaces (1305 templates)

            Configuration and access:
            - 'misconfig': Misconfiguration detection (739 templates)
            - 'config': Configuration issues (253 templates)
            - 'login': Login-related vulnerabilities (431 templates)
            - 'default-login': Default login credentials (263 templates)
            - 'auth-bypass': Authentication bypass (178 templates)
            - 'unauth': Unauthenticated access (415 templates)

            CMS-specific:
            - 'wordpress': WordPress vulnerabilities (1143 templates)
            - 'wp-plugin': WordPress plugin vulnerabilities (1002 templates)
            - 'wp': General WordPress (554 templates)
            - 'joomla': Joomla vulnerabilities (151 templates)

            Cloud platforms:
            - 'cloud': Cloud service vulnerabilities (694 templates)
            - 'aws': Amazon Web Services (192 templates)
            - 'azure': Microsoft Azure (210 templates)
            - 'gcp': Google Cloud Platform (232 templates)
            - 'amazon': Amazon services (175 templates)
            - 'microsoft': Microsoft services (235 templates)

            Infrastructure:
            - 'apache': Apache server vulnerabilities (234 templates)
            - 'network': Network service vulnerabilities (215 templates)
            - 'file': File-related vulnerabilities (376 templates)
            - 'iot': Internet of Things vulnerabilities (176 templates)

            Other categories:
            - 'osint': Open-source intelligence gathering (808 templates)
            - 'devops': DevOps-related vulnerabilities (736 templates)
            - 'malware': Malware detection (213 templates)
            - 'token': Token-related issues (211 templates)
            - 'keys': API keys and sensitive data (156 templates)
            - 'redirect': Open redirect vulnerabilities (156 templates)

            This parameter is required - you must specify which tags to use for scanning.
        severity: Filter by severity - "critical", "high", "medium", "low", "info"
        timeout: Scan timeout in seconds (will return partial results if timeout)
        rate_limit: Requests per second limit

    Returns:
        NucleiScanResult with findings, count, and metadata
    """
    process = None
    temp_file = None

    try:
        # Check templates first
        logging.info("ğŸ”„ Checking nuclei templates...")
        _update_templates()

        temp_file = create_temp_file()

        cmd = _create_command(
            target=target,
            tags=tags,
            temp_file=temp_file,
            severity=severity,
            rate_limit=rate_limit,
        )

        logging.info(f"ğŸš€ Starting nuclei scan: {' '.join(cmd)}")
        start_time = time.time()

        process = execute_process(cmd)
        scan_completed = await wait_for_process_completion(process, timeout, start_time)

        res = _read_temp_file(temp_file, scan_completed)
        return res
    except Exception as e:
        logging.error(f"Error during nuclei scan: %s", e)
        return NucleiScanResult.create_error(f"Nuclei scan failed: {str(e)}")
    finally:
        terminate_process(process)
        delete_temp_file(temp_file)


def _read_temp_file(temp_file: str, scan_completed: bool) -> NucleiScanResult:
    """Read JSONL file and return structured results."""
    findings = []

    try:
        with open(temp_file, "r") as f:
            content = f.read().strip()

            if not content:
                logging.info("No findings in nuclei output file")
                return NucleiScanResult(
                    findings=[], count=0, scan_completed=scan_completed
                )

            # Process each line as separate JSON object (JSONL format)
            for line_num, line in enumerate(content.split("\n"), 1):
                line = line.strip()
                if line:
                    try:
                        finding_data = json.loads(line)
                        # Validate and parse with Pydantic
                        finding = NucleiFinding.model_validate(finding_data)
                        findings.append(finding)
                    except json.JSONDecodeError as e:
                        logging.warning(
                            f"Failed to parse JSON line {line_num}: {line} - {e}"
                        )
                    except ValidationError as e:
                        logging.warning(
                            f"Failed to validate finding data line {line_num}: {e}"
                        )

        logging.info(f"Successfully parsed {len(findings)} findings from nuclei output")

        return NucleiScanResult(
            findings=findings, count=len(findings), scan_completed=scan_completed
        )

    except Exception as e:
        logging.error(f"Error reading nuclei output file: {e}")
        return NucleiScanResult.create_error(f"Failed to read results: {str(e)}")


def _update_templates():
    subprocess.run(
        ["nuclei", "-update-templates"], capture_output=True, text=True, timeout=60
    )


def _create_command(
    target: str,
    tags: list[str],
    temp_file: str,
    severity: str | None = None,
    rate_limit: int = 15,
) -> list[str]:
    cmd = [
        "nuclei",
        "-u",
        target,
        "-tags",
        ",".join(tags),
        "-o",
        temp_file,
        "-jsonl",
        # "-silent",
        "-rate-limit",
        str(rate_limit),
    ]

    if severity:
        cmd.extend(["-severity", severity])

    return cmd
