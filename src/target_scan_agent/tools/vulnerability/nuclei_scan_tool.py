import subprocess
import time
import asyncio
import json
import logging
import os
from pydantic import ValidationError

from .models import NucleiScanResult, NucleiFinding
from ..common.process_utils import (
    create_temp_file,
    delete_temp_file,
    execute_process,
    terminate_process,
    wait_for_process_completion,
)


scan_strategies = {
    "quick": {
        "tags": ["tech-detect", "exposure"],
        "description": "Quick technology and exposure scan",
    },
    "comprehensive": {
        "tags": ["tech-detect", "exposure", "misconfig"],
        "description": "Comprehensive vulnerability scan",
    },
    "tech-detect": {
        "tags": ["tech-detect"],
        "description": "Technology detection scan",
    },
    "misconfig": {
        "tags": ["misconfig", "exposure"],
        "description": "Misconfiguration scan",
    },
    "cve-only": {
        "tags": ["cve"],
        "description": "CVE vulnerability scan",
    },
}


async def nuclei_scan_tool(
    target: str,
    scan_type: str = "quick",
    severity: str | None = None,
    timeout: int = 900,
    rate_limit: int = 15,
) -> NucleiScanResult:
    """
    Run Nuclei vulnerability scanner and return structured results.

    Args:
        target: URL to scan (e.g., "http://localhost:8000")
        scan_type: Scan strategy - "quick", "comprehensive", "tech-detect", "misconfig", "cve-only"
        severity: Filter by severity - "critical", "high", "medium", "low", "info"
        timeout: Scan timeout in seconds (will return partial results if timeout)
        rate_limit: Requests per second limit

    Returns:
        NucleiScanResult with findings, count, and metadata
    """
    process = None
    temp_file = None

    try:
        # Check templates first
        logging.info("🔄 Checking nuclei templates...")
        _update_templates()

        temp_file = create_temp_file()

        cmd = _create_command(
            target=target,
            scan_type=scan_type,
            temp_file=temp_file,
            severity=severity,
            rate_limit=rate_limit,
        )

        logging.info(f"🚀 Starting nuclei scan: {' '.join(cmd)}")
        start_time = time.time()

        process = execute_process(cmd)
        scan_completed = await wait_for_process_completion(process, timeout, start_time)

        res = _read_temp_file(temp_file, scan_completed)
        return res
    except Exception as e:
        logging.error(f"Error during nuclei scan: %s", e)
        return NucleiScanResult.create_error(f"Nuclei scan failed: {str(e)}")
    finally:
        terminate_process(process)
        delete_temp_file(temp_file)


def _read_temp_file(temp_file: str, scan_completed: bool) -> NucleiScanResult:
    """Read JSONL file and return structured results."""
    findings = []
    
    try:
        with open(temp_file, "r") as f:
            content = f.read().strip()
            
            if not content:
                logging.info("No findings in nuclei output file")
                return NucleiScanResult(
                    findings=[],
                    count=0,
                    scan_completed=scan_completed
                )
            
            # Process each line as separate JSON object (JSONL format)
            for line_num, line in enumerate(content.split('\n'), 1):
                line = line.strip()
                if line:
                    try:
                        finding_data = json.loads(line)
                        # Validate and parse with Pydantic
                        finding = NucleiFinding.model_validate(finding_data)
                        findings.append(finding)
                    except json.JSONDecodeError as e:
                        logging.warning(f"Failed to parse JSON line {line_num}: {line} - {e}")
                    except ValidationError as e:
                        logging.warning(f"Failed to validate finding data line {line_num}: {e}")
                        
        logging.info(f"Successfully parsed {len(findings)} findings from nuclei output")
        
        return NucleiScanResult(
            findings=findings,
            count=len(findings),
            scan_completed=scan_completed
        )
        
    except Exception as e:
        logging.error(f"Error reading nuclei output file: {e}")
        return NucleiScanResult.create_error(f"Failed to read results: {str(e)}")


async def _wait_execution(
    process: subprocess.Popen, timeout: int, start_time: float
) -> bool:
    last_check_time = start_time

    while True:
        poll_result = process.poll()
        if poll_result is not None:
            logging.info(f"✅ Nuclei completed (exit code: {poll_result})")
            # Ignore stdout/stderr
            process.communicate()
            return True  # Scan completed successfully

        elapsed = time.time() - start_time
        if elapsed > timeout:
            logging.info(
                f"⏱️ Timeout reached ({timeout}s), collecting partial results..."
            )
            terminate_process(process)
            # Ignore stdout/stderr
            process.communicate()
            return False  # Scan was interrupted by timeout

        if time.time() - last_check_time > 30:
            logging.info(f"📊 Scan in progress... ({elapsed:.0f}s elapsed)")
            last_check_time = time.time()

        await asyncio.sleep(1)


def _update_templates():
    subprocess.run(
        ["nuclei", "-update-templates"], capture_output=True, text=True, timeout=60
    )


def _create_command(
    target: str,
    scan_type: str,
    temp_file: str,
    severity: str | None = None,
    rate_limit: int = 15,
) -> list[str]:
    strategy = scan_strategies.get(scan_type, scan_strategies["quick"])
    cmd = [
        "nuclei",
        "-u",
        target,
        "-tags",
        ",".join(strategy["tags"]),
        "-o",
        temp_file,
        "-jsonl",
        # "-silent",
        "-rate-limit",
        str(rate_limit),
    ]

    if severity:
        cmd.extend(["-severity", severity])

    return cmd


