import subprocess
import tempfile
import os
import time
import asyncio
import logging


scan_strategies = {
    "quick": {
        "tags": ["tech-detect", "exposure"],
        "description": "Quick technology and exposure scan",
    },
    "comprehensive": {
        "tags": ["tech-detect", "exposure", "misconfig"],
        "description": "Comprehensive vulnerability scan",
    },
    "tech-detect": {
        "tags": ["tech-detect"],
        "description": "Technology detection scan",
    },
    "misconfig": {
        "tags": ["misconfig", "exposure"],
        "description": "Misconfiguration scan",
    },
    "cve-only": {
        "tags": ["cve"],
        "description": "CVE vulnerability scan",
    },
}


async def nuclei_scan_tool(
    target: str,
    scan_type: str = "quick",
    severity: str | None = None,
    timeout: int = 900,
    rate_limit: int = 15,
) -> str:
    """
    Run Nuclei vulnerability scanner and return raw JSON output as string.

    Args:
        target: URL to scan (e.g., "http://localhost:8000")
        scan_type: Scan strategy - "quick", "comprehensive", "tech-detect", "misconfig", "cve-only"
        severity: Filter by severity - "critical", "high", "medium", "low", "info"
        timeout: Scan timeout in seconds (will return partial results if timeout)
        rate_limit: Requests per second limit

    Returns:
        Raw nuclei JSON output as string (JSONL format)
    """
    process = None
    temp_file = None

    try:
        # Check templates first
        logging.info("🔄 Checking nuclei templates...")
        _update_templates()

        temp_file = _create_temp_file()

        cmd = _create_command(
            target=target,
            scan_type=scan_type,
            temp_file=temp_file,
            severity=severity,
            rate_limit=rate_limit,
        )

        logging.info(f"🚀 Starting nuclei scan: {' '.join(cmd)}")
        start_time = time.time()

        process = _execute_process(cmd)
        stdout, stderr = await _wait_execution(process, timeout, start_time)

        logging.info(f"stdout: %s", stdout)
        logging.info(f"stderr: %s", stderr)

        res = _read_temp_file(temp_file)
        return res
    except Exception as e:
        logging.error(f"Error during nuclei scan: %s", e)
        return f"Nuclei scan failed: {str(e)}"
    finally:
        _terminate_process(process)
        _delete_temp_file(temp_file)


def _read_temp_file(temp_file: str) -> str:
    with open(temp_file, "r") as f:
        return f.read().strip()


async def _wait_execution(
    process: subprocess.Popen, timeout: int, start_time: float
) -> tuple[str, str]:
    last_check_time = start_time

    while True:
        poll_result = process.poll()
        if poll_result is not None:
            logging.info(f"✅ Nuclei completed (exit code: {poll_result})")
            return process.communicate()

        elapsed = time.time() - start_time
        if elapsed > timeout:
            logging.info(
                f"⏱️ Timeout reached ({timeout}s), collecting partial results..."
            )
            _terminate_process(process)

            return process.communicate()

        if time.time() - last_check_time > 30:
            logging.info(f"📊 Scan in progress... ({elapsed:.0f}s elapsed)")
            last_check_time = time.time()

        await asyncio.sleep(1)


def _update_templates():
    subprocess.run(
        ["nuclei", "-update-templates"], capture_output=True, text=True, timeout=60
    )


def _create_temp_file() -> str:
    with tempfile.NamedTemporaryFile(mode="w+", suffix=".jsonl", delete=False) as f:
        return f.name


def _create_command(
    target: str,
    scan_type: str,
    temp_file: str,
    severity: str | None = None,
    rate_limit: int = 15,
) -> list[str]:
    strategy = scan_strategies.get(scan_type, scan_strategies["quick"])
    cmd = [
        "nuclei",
        "-u",
        target,
        "-tags",
        ",".join(strategy["tags"]),
        "-o",
        temp_file,
        "-jsonl",
        "-silent",
        "-rate-limit",
        str(rate_limit),
    ]

    if severity:
        cmd.extend(["-severity", severity])

    return cmd


def _execute_process(cmd: list[str]) -> subprocess.Popen:
    return subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        cwd=os.path.expanduser("~"),
    )


def _terminate_process(process: subprocess.Popen | None):
    # Ensure cleanup
    if process and process.poll() is None:
        try:
            process.terminate()
            process.wait(timeout=5)
        except:
            try:
                process.kill()
            except:
                pass


def _delete_temp_file(temp_file: str | None):
    if temp_file and os.path.exists(temp_file):
        try:
            os.unlink(temp_file)
        except:
            pass
